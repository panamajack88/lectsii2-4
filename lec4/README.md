## Первая программа четвёртой лекции
Сначала программа получает сигнал от пользователя и обрабатывает его. В шестой строчке задаётся глобальная переменная-счётчик counter. Также в программе присутствуют две обрабатывающие функции - handler1(8-14 строчки) и handler2 (16-20 строчки). Они принимают агрумент типа int. Handler1 увеличивает счётчик на 1 и отправляет сигнал дочернему. Обработка выглядит следующим образом: Программа привязывает первую функцию обработки к текущему процессу. Далее если процесс окажется дочерним, сигнал будет обрабатывать функция handler2.

## Screen
![lec4_1](https://user-images.githubusercontent.com/83709401/169609464-a36363b2-939b-415f-bf06-aff7e5df086f.jpg)

## Вторая программа четвёртой лекции 
Сначала программа создаёт массив файловых дескрипторов. После этого приложение проверит корректность ввода и сообщит об ошибке если нужно (14 и 20 строчки). Затем программа вызовет fork() для получения PID'а дочернего процесса. Дальше приложение проверит только что полученный PID. У дочернего элемента этот идентификатор равен нулю. Далее родительский процесс пишет что-либо в канал (42-49), а дочерний читает(34-42). Таким образом реализуется общение между процессами с помощью канала.

## Screen
![lec4_2](https://user-images.githubusercontent.com/83709401/169609473-2528df18-5191-4cea-be11-f13c71be5000.jpg)

## Третья программа четвёртой лекции 
Сначала программа создаёт дескриптор и канал с правами доступа для всех (14-23). После этого запускается бесконечный цикл, в котором приложение прослушивает его (32-41). Если программа получила сообщение (34ая строчка), она выведет количество символов (учитывая терминальный ноль) и сам текст.

## Screen
![lec4_3](https://user-images.githubusercontent.com/83709401/169609487-d10439c8-6b09-491f-8680-6b34f2dec4c8.jpg)
